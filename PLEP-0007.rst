==============================================
PLEP-0007 â€“ A Next Generation Plasma Simulator
==============================================

+-------------------+---------------------------------------------+
| PLEP              | number                                      |
+===================+=============================================+
| author(s)         | Nicholas A. Murphy                          |
+-------------------+---------------------------------------------+
| contact email     | namurphy@cfa.harvard.edu                    |
+-------------------+---------------------------------------------+
| date created      | 2018-12-17                                  |
+-------------------+---------------------------------------------+
| date last revised | 2019-01-02                                  |
+-------------------+---------------------------------------------+
| type              | standard                                    |
+-------------------+---------------------------------------------+
| status            | discussion                                  |
+-------------------+---------------------------------------------+
| DOI               |                                             |
|                   |                                             |
+-------------------+---------------------------------------------+

Abstract
========

This proposal describes the current status of simulation software in
the plasma physics community and describes a next generation general
purpose plasma simulation framework in the PlasmaPy ecosystem.  This
plasma simulator should be developed with sufficient modularity and
flexibility to enable straightforward switching of both physical
models and numerical methods.

*Due to the magnitude of this project, this PLEP will be implemented
only if sufficient funding for code development becomes available.*

Background
==========

Numerical simulation is a powerful research tool that allows us to
investigate plasma phenomena such as disruptions in tokamaks, solar
eruptions, and accretion into black holes.  Numerical methods for
plasma simulation are continually advancing.


Major problems include:

* Verification and validation (how do we compare against reality?)

Open source plasma simulation codes include:

Current Status of Plasma Simulation Research
--------------------------------------------

Major successes include:

* Highly sophisticated simulations of tokamaks

* Reaching petascale computing

* Turbulence studies

* GRMHD, simulation of plasmas in extreme environments

Sample major topics include:

* Whole device simulation of tokamaks
* Multi-scale simulations of magnetic reconnection in the solar corona
  (where PIC and fluid codes are important)

Current Status of Plasma Simulation Software
--------------------------------------------

* **Numerical methods for plasma simulations are very advanced.**
  Plasma scientists have developed highly sophisticated numerical
  methods for simulating the behavior of laboratory, heliospheric,
  space, and astrophysical plasmas.

* **Plasma simulation codes are usually written in low level compiled
  languages such as Fortran and C.** While these compiled languages
  offer excellent performance, code development is significantly slowed
  down because the languages are not interactive and variable types must
  be declared.

* **Access to codes is commonly restricted in some way.** Closed
  source codes hinder scientific reproducibility.  Open source codes
  often have a lower density of bugs because more people are able to
  review the code and make contributions.

* **Codes often lack sufficient documentation.**  Often it is
  necessary to work closely with a core developer of a code in order
  to set up a problem.

* **Code compilation and installation is often difficult and
  time-consuming.** This is particularly true for codes that depend on
  external libraries or include multiple languages.  Compilation often
  requires detailed knowledge of makefiles which is a significant
  barrier to entry for newcomers.  Lack of documentation on how to
  compile code exacerbates this problem.

* **Codes frequently lack unit testing and continuous integration
  testing frameworks.**  These testing strategies help us improve the
  reliability of the code, track down bugs as soon as they appear, and
  greatly reduce the likelihood that we will introduce bugs as we
  modify or maintain the code.

* **Code is often difficult to read.**  Codes commonly use highly
  abbreviated variable names that obfuscate what the variable
  represents, especially when there are no comments that describe what

* **Benchmarking two algorithms or comparing physical models usually
  requires setting up the same problem in multiple codes.** Usually
  the same case must be set up by an experienced or expert user of
  each code.  Often this requires careful discussions to make sure
  that things like normalizations and boundary conditions are able to
  be matched.  The data are often stored in different formats, so

* **The code for the problem setup, physical model, and numerical
  method are often intertwined with each other.**  When these aspects

* **Simulation output is rarely stored in a standardized form.** Few
  standards exist (with the exception of OpenPMD).  The lack of a
  standardized format makes developing general purpose plotting
  software much more difficult.

* **Code is often difficult to maintain.**

* **Research projects involving plasma simulations are usually very
  difficult to reproduce.**

Project Goals
=============

We propose to develop a flexible open source framework for plasma
simulation.  The choice of Julia will allow us to optimize both
performance and productivity.  Julia's use of a JIT compiler allows
programs to achieve performance comparable to compiled languages like
Fortran and C.  Productivity is enhanced because Julia is a dynamically
typed language that can be used interactively and because
parallelization is a built-in feature of the language.  Flexibility will
be achieved by taking a modular approach and using well-defined abstract
interfaces.

* **Allow users to perform high quality plasma simulations with the
  minimal amount of effort and required knowledge.**

* **Allow users to switch between physical models and numerical methods
  with minimal effort.**

* **Optimize for both productivity and performance.**

* **Code should be readable, and self-documenting when possible.**

* **Provide readable and maintainable code.**  Code should be
  self-documenting when possible.

* **Make it hard for users to make mistakes.**

* **Provide a package that can be installed in one or two lines.**

* **Begin development using well-understood, published numerical
  methods.**

Anticipated User Experience
===========================

A requirement of this package is to allow users to specify the problem
setup, physical model, and numerical method as independently as
possible.  This separation of responsibilities is necessary to allow
users to straightforwardly switch between different systems of equations
and computational algorithms.

Users will first create a problem setup object or module that should
contain all of the information necessary to set up a simulation
independent of physical model and numerical method.

* Coordinate system
* Physical domain
* Initial conditions
* Boundary conditions
* Time interval

The choice of coordinate system will provide the dimensionality (i.e.,
if the simulation is 1D, 2D, or 3D).  The physical domain should be
capable of being multiply connected or with a more complicated geometry
(such as a stellarator).  The initial and boundary conditions will
provide a list of the dependent variables.  The initial conditions
should be able to be specified by

* Choosing a pre-defined standard setup
* Specifying functions for different fields
* Passing in arrays of values
* Using helper tools such as a Grad-Shafranov solver

The boundary conditions should be able to be specified by

* Choosing pre-defined boundary conditions (e.g., periodic or no-slip
  conducting wall boundaries)
* Specifying functions for different fields along different boundaries

For fluid simulations, users will create a physical model object that
contains the system of equations.


.. Users will next define the system of equations or physical model to be
   solved.  It is at this point that users will choose the style of
   simulation (including but not limited to fluid, particle-in-cell, and
   hybrid approaches).  The physical model will be checked to be consistent
   with the initial and boundary conditions.

.. Users will then define the numerical method and specify inputs for the

.. Users define the problem setup.  This is done independently of the
    physical model (with the caveat that all fields have to be defined or
    assumed to be zero, and also be physically realizable).  The package
    will check that all three are consistent with each other.
  - Physical domain
    - Coordinate system
    - Dimensionality
    - Size
    - Allow for multiply connected geometries (like in MRX)
  - Initial conditions
  - Boundary conditions
    - Have pre-set BCs for things like a conducting wall.  BCs can be
      messy to implement, like putting them into a
* Users define the physical model.
  - Options for user input
    - Pre-defined sets of equations with options to specify different
      coefficients (like resistive MHD with uniform, Spitzer, anomalous,
      or a user-defined function)
    - List of strings containing the different equations
  - If the equations are in conservative form (including with sources
    and sinks) then
  - We can have pre-defined sets of equations
  - We can have pre-defined sets of equations as a string (including
    unicode characters) following Dedalus approach
    - This can be done best if numerical method can be automagically
      generated
    - Julia allows us to pass functions around as arguments (A function
      can have a function as an argument, and a function can return a
      function)
  - We can sometimes use pre-set equations (like resistive MHD, with
    uniform or temperature dependent or anomalous resistivity)
  - Numerical method
  * Post-processing
  - Maybe we could create a function that automatically writes text that
    describes the numerical method and such.

Proposed Package Structure
==========================

.. Mathematical functions
  - Basis functions that are not defined in other packages
  * Physics coefficients
  - Resistivities
  - Transport coefficients
  - Plasma parameters
  * Built-in grid tools
  - Methods for creating a grid
  - Should be able to define:
    - Finite difference grids (including staggered grids)
    - Finite volume grids (including staggered grids)
    - Finite element and spectral element grids
      - Including for multiply defined geometries
  - Ways to specify grids for finite difference and finite volume
    methods (including on staggered grids)
  - Ways to specify grids

Choice of language
==================

Julia is a new high-level open source language that synthesizes the best
features of Fortran, C, Python, R, MATLAB, and Lisp for scientific
computing.  Julia uses a just-in-time (JIT) compiler with type inference
and multiple dispatch to achieve performance comparable to C and
Fortran.  Unlike C and Fortran, Julia can be run interactively and does
not require type declarations.  These features greatly speed up code
development by allowing prototyping in the same language to be used for
performance runs.  Julia natively supports parallelization, and has been
used to achieve petascale computing.  **Julia proves that high
performance can be achieved with a dynamically typed interactive
language without sacrificing usability.**

Julia can call code from Fortran and C, and can act as a wrapper for
codes written in these compiled languages.  The main drawback of this
approach is that the resulting code would be harder to maintain because
developers would need to know two or three languages.  A potential
drawback is that problems can arise in practice when code in one
language is called from a different language.  Global optimizations
might also not be possible when mixing more than one language (though
Julia may become capable of optimizations across language boundaries in
the future.  If possible, the package itself should be written entirely
in Julia and depend only on packages that can be installed using Julia's
built-in package manager.  Users shall *not* be required to compile or
install any external libraries or use any shell scripts.

The implementation shall be written entirely in Julia, but shall have a
Python interface.  The interface may either be included in the PlasmaPy
core package or in an affiliated package.  The ``Plasma`` class should
be able to handle the output of simulations performed using this plasma
simulation framework.

Development Principles
======================

* **Optimize for both productivity and performance.**  With Julia, it is
  possible to have the performance of a compiled language with the

.. Plasma simulation
  should be straightforward

* **Develop the overall architecture under the point of view that we
  have not decided on the numerical method or physical model yet.**

* **Make the code as modular as possible.**

* **Optimize for both productivity and performance.**  Plasma simulation
  should be straightforward.  Running plasma simulations should not
  require expertise into the details of the code.  Code should be
  optimized for performance only after it works, and then only after it
  becomes apparent what the bottlenecks are.

* **Prioritize usability, readability, and maintainability.**  Code
  should be straightforward to install.  The packages resulting from
  this project should all be installable by using Julia's built-in
  package manager.

* **The software should be easy to install.**  The plasma simulation
  package should be installable using Julia's built-in package manager.
  Users shall not be required to run bash scripts or install libraries.

* **Prioritize documentation.**  The documentation should be
  sufficient for a student taking their first plasma physics class to
  be able to use it without too much difficulty.

* **Prioritize flexible numerical methods.**  There are a number of
  numerical methods that have been developed for systems of equations
  written in conservative form.

* **Minimize the amount of work and knowledge required by the end
  user.**

* **Make it difficult for users to make silent mistakes.**

* **Make it straightforward to perform convergence studies and to test
  solutions using different numerical methods.**

* **Use the SOLID principles for software development.**

  - The *single responsibility principle*: There should never be more
    than one reason for a class to change.

  - The *open-closed principle*: Software entities (classes, modules,
    functions, etc.) should be open for extension but closed for
    modification.

  - The *Liskov substitution principle*: Objects in a program should
    be replaceable with instances of their subtypes without altering
    the correctness of that program.

  - The *interface segregation principle*: Clients should not be
    forced to depend upon interfaces that they do not use.

  - The *dependency inversion principle*: High level modules should
    not depend upon low level modules.  Abstractions should not depend
    upon details.  Details should depend upon abstractions.

Implementation Notes
====================

Abstract Interfaces
-------------------

`Abstract base classes
<https://docs.python.org/3.7/library/abc.html>`_ (ABCs) in Python
allow users to define what methods and attributes must be defined in a
subclass of that ABC.  This functionality is used in PlasmaPy's
``Plasma`` class.  An equivalent to ABCs has not yet been implemented
in Julia (see `Julia issue #6875 on GitHub
<https://github.com/JuliaLang/julia/issues/6975>`_).  An alternative
to ABCs would be to create a macro that checks that a particular class
or class instance has all of the required methods.

Issues, Pull Requests, and Branches
===================================

Backward Compatibility
======================

Creation of this general purpose plasma simulator may necessitate
changes to base classes such as ``Plasma`` which are still under
development.

Alternatives
============

Julia is not the only language that could be used for this project.
The main alternatives are listed below.  The most significant
disadvantages are shown in bold.

* **Fortran**, **C**, or **C++**
  - Advantages
    - Exceptional performance as a compiled language
    - Many plasma physicists have considerable knowledge and
      experience with these languages
    - Can call code from Python
  - Disadvantages
    - **Development is greatly slowed because the language is not
      interactive**
    - Code in these languages is often several times the length of
      equivalent code in Julia or Python
    - Continuous integration testing platforms such as Travis CI do
      not support direct testing of Fortran code
    - Experience with Fortran is less likely to be helpful for plasma
      physics students who find jobs outside of research and academia

* **Python with NumPy**
  - Advantages
    - Fast development
    - No need to compile code
  - Disadvantage
    - **Slow performance as an interpreted language**
    - NumPy does not offer a sufficient speedup

* **Python with Cython**
  - Advantages
    - Because Cython allows us to generate C code from Python-like
      code, we are able to get compiled speeds
    - Allows for a Python interface
  - Disadvantages
    - **Cython is difficult to work with and maintain**

* **Python with Numba**
  - Advantages
    - Uses a just-in-time compiler to get compiled speeds
    - Often decorating a function with ``numba.jit`` is enough to get
      compiled speeds
  - Disadvantages
    - Because Numba compiles one function at a time, it may be unable
      to do global optimizations while compiling
    - **Does not yet provide a full language solution to the
      performance vs. productivity conundrum**

* **LuaJIT**
  - Advantages
    - Uses a just-in-time compiler to get compiled speeds
    - Offers exceptional performance, including for graphical
      processing units (GPUs)
  - Disadvantages
    - **Less active community surrounding scientific LuaJIT**
    - Fewer scientific libraries written in LuaJIT

Decision Rationale
==================

This PLEP has not been decided upon yet.
