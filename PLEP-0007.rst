==============================================
PLEP-0007 â€“ A Next Generation Plasma Simulator
==============================================

+-------------------+---------------------------------------------+
| PLEP              | number                                      |
+===================+=============================================+
| author(s)         | Nicholas A. Murphy                          |
+-------------------+---------------------------------------------+
| contact email     | namurphy@cfa.harvard.edu                    |
+-------------------+---------------------------------------------+
| date created      | 2018-12-17                                  |
+-------------------+---------------------------------------------+
| date last revised | 2018-12-18                                  |
+-------------------+---------------------------------------------+
| type              | standard                                    |
+-------------------+---------------------------------------------+
| status            | discussion                                  |
+-------------------+---------------------------------------------+
| DOI               |                                             |
|                   |                                             |
+-------------------+---------------------------------------------+

Abstract
========

This proposal describes the current status of simulation software in
the plasma physics community and describes a next generation general
purpose plasma simulation framework in the PlasmaPy ecosystem.  This
plasma simulator should be developed with sufficient modularity and
flexibility to enable straightforward switching of both physical
models and numerical methods.

*Due to the magnitude of this project, this PLEP will be implemented
only if sufficient funding for code development becomes available.*

Background
==========

Numerical simulation is a powerful research tool that allows us to
investigate plasma phenomena such as disruptions in tokamaks, solar
eruptions, and accretion into black holes.  Numerical methods for
plasma simulation are continually advancing.  

Current Status of Plasma Simulation
-----------------------------------

* **Development of numerical methods for plasma simulations are very
  advanced.**

* **Codes are usually written in low level compiled languages such as
  Fortran and C.** While these compiled languages offer excellent
  performance, code development is significantly slowed down because
  the languages are not interactive and variable types must be
  declared.

* **Access to codes is commonly restricted in some way.** Closed
  source codes hinder scientific reproducibility.  Open source codes
  often have a lower density of bugs because more people are able to
  review the code and make contributions.

* **Codes often lack sufficient documentation.**  Often it is
  necessary to work closely with a core developer of a code in order
  to set up a problem.

* **Code compilation and installation is often difficult and
  time-consuming.** This is particularly true for codes that depend on
  external libraries or include multiple languages.  Compilation often
  requires detailed knowledge of makefiles which is a significant
  barrier to entry for newcomers.  Lack of documentation on how to
  compile code exacerbates this problem.

* **Codes frequently lack unit testing and continuous integration
  testing frameworks.** These testing strategies help us improve the
  reliability of the code, track down bugs as soon as they appear, and
  greatly reduce the likelihood that we will introduce bugs as we
  modify or maintain the code.  Continuous integration testing
  platforms such as Travis CI do not support direct testing of Fortran
  code.

* **Code is often diffucult to read.** Often code uses highly
  abbreviated variable names that obfuscate what the variable
  represents.

* **Benchmarking two algorithms or comparing physical models usually
  requires setting up the same problem in multiple codes.** Usually
  the same case must be set up by an experienced or expert user of
  each code.  Often this requires careful discussions to make sure
  that things like normalizations and boundary conditions are able to
  be matched.  The data are often stored in different formats, so 

* **The code for the problem setup, physical model, and numerical
  method are often intertwined with each other.**  When these aspects

* **Simulation output is rarely stored in a standardized form.** Few
  standards exist (with the exception of OpenPMD).  The lack of a
  standardized format makes developing general purpose plotting
  software much more difficult.

* **Code is often difficult to maintain.**

* **Research projects involving plasma simulations are difficult to
  reproduce.**

Detailed Description
====================





Development Principles
======================

* **Optimize for both productivity and performance.**  Plasma
  simulation should be straightforward and not require expertise into
  the details of the code.  Optimize code only after it works, and
  then only after it becomes apparent what the bottlenecks are.

* **Prioritize readability, usability, and maintainability.**  Code
  should be straightforward to install.

* **Prioritize documentation.**  The documentation should be
  sufficient for a student taking their first plasma physics class to
  be able to use it without too much difficulty.

* **Make the code as modular as possible.**

* **Use the SOLID principles for software development.**

  - The *single responsibility principle*: There should never be more
    than one reason for a class to change.

  - The *open-closed principle*: Software entities (classes, modules,
    functions, etc.) should be open for extension but closed for
    modification.

  - The *Liskov substitution principle*: Objects in a program should
    be replaceable with instances of their subtypes without altering
    the correctness of that program.

  - The *interface segregation principle*: Clients should not be
    forced to depend upon interfaces that they do not use.

  - The *dependency inversion principle*: High level modules should
    not depend upon low level modules.  Abstractions should not depend
    upon details.  Details should depend upon abstractions.

Implementation
==============

Choice of language
------------------

Julia is a new high-level open source language that synthesizes the
best features of Fortran, C, Python, R, MATLAB, and Lisp for
scientific computing.  Julia uses a just-in-time compiler with type
inference and multiple dispatch to acheive performance comparable to C
and Fortran.  Unlike C and Fortran, Julia can be run interactively
which greatly speeds up code development and allows prototyping in the
same language to be used for performance runs.  Julia natively
supports parallelization and can call code from Fortran, C, and
Python.  Julia proves that high performance can be acheived with a
dynamic interactive language.

Abstract Interfaces
-------------------

`Abstract base classes
<https://docs.python.org/3.7/library/abc.html>`_ (ABCs) in Python
allow users to define what methods and attributes must be defined in a
subclass of that ABC.  This functionality is used in PlasmaPy's
``Plasma`` class.  An equivalent to ABCs has not yet been implemented
in Julia (see `Julia issue #6875 on GitHub
<https://github.com/JuliaLang/julia/issues/6975>`_).  An alternative
to ABCs would be to create a macro that checks that a particular class
or class instance has all of the required methods.

Python interface
----------------

The implementation shall be written entirely in Julia, but shall have
a Python interface.  The interface may either be included in the
PlasmaPy core package or as an affiliated package.

Issues, Pull Requests, and Branches
===================================

* 

Backward Compatibility
======================

Creation of this general purpose plasma simulator may necessitate
changes to base classes such as ``Plasma`` which are still under
development.

Alternatives
============

Julia is not the only language that could be used for this project.
The main alternatives are listed below.  The most significant
disadvantages are shown in bold.

* **Fortran**, **C**, or **C++**
  - Advantages
    - Exceptional performance as a compiled language
    - Many plasma physicists have considerable knowledge and
      experience with these languages
    - Can call code from Python
  - Disadvantages
    - **Development is greatly slowed because the language is not
      interactive**
    - Code in these languages is often several times the length of
      equivalent code in Julia or Python
    - Continuous integration testing platforms such as Travis CI do
      not directly support testing of Fortran code
    - Experience with Fortran is less likely to be helpful for plasma
      physics students who find jobs outside of research and academia

* **Python with NumPy**
  - Advantages
    - Fast development
    - No need to compile code
  - Disadvantage
    - **Slow performance as an interpreted language**
    - NumPy does not offer a sufficient speedup

* **Python with Cython**
  - Advantages
    - Because Cython allows us to generate C code from Python-like
      code, we are able to get compiled speeds
    - Allows for a Python interface
  - Disadvantages
    - **Difficult to work with and maintain**

* **Python with Numba**
  - Advantages
    - Uses a just-in-time compiler to get compiled speeds
    - Often decorating a function with ``numba.jit`` is enough to get
      compiled speeds
  - Disadvantages
    - Because Numba compiles one function at a time, it may be unable
      to do global optimizations while compiling
    - **Does not yet provide a full language solution to the
      performance vs. productivity conundrum**

* **LuaJIT**
  - Advantages
    - Uses a just-in-time compiler to get compiled speeds
    - Offers exceptional performance, including for graphical
      processing units (GPUs)
  - Disadvantages
    - **Less active community surrounding scientific LuaJIT**
    - Fewer scientific libraries written in LuaJIT

Decision Rationale
==================

This PLEP has not been decided upon yet.
